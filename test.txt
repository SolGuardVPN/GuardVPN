DVPN PROJECT - COMPLETE TESTING GUIDE
=====================================
Date: January 5, 2026
Status: All features implemented (except staking/slashing and Electron client - reserved for later)


TABLE OF CONTENTS
=================
1. WHAT'S IMPLEMENTED
2. ON-CHAIN PROGRAM FEATURES & TESTING
3. OFF-CHAIN INFRASTRUCTURE & TESTING
4. INDEXER SERVICE TESTING
5. FULL END-TO-END TESTING WORKFLOW
6. RESERVED FEATURES (Not Deployed Yet)


====================================================================================
SECTION 1: WHAT'S IMPLEMENTED
====================================================================================

‚úÖ ON-CHAIN (Solana Program):
   - Provider registration with reputation tracking
   - Node registration with capacity limits
   - Session creation (SOL and USDC/SPL tokens)
   - Reputation system (scores, uptime tracking)
   - Usage-based billing (receipt-based claims)
   - Partial refunds for early session closure
   - Dispute mechanism with slashing capability
   - Proof-of-service tracking (bytes used, proof hashes)
   - Staking infrastructure (code ready, not deployed)

‚úÖ OFF-CHAIN (Node Infrastructure):
   - WireGuard server integration
   - Node daemon HTTP server for session authentication
   - Automatic peer provisioning/removal
   - Usage tracking and receipt submission
   - Auto payout claims
   - Traffic monitoring

‚úÖ INDEXER:
   - PostgreSQL database with full schema
   - Real-time blockchain syncing (every 5s)
   - REST API for querying nodes/sessions/providers
   - Filtering by region, reputation, status

‚úÖ SCRIPTS & TOOLS:
   - Provider/node creation scripts
   - Session management scripts
   - PDA computation utilities
   - Fetch and scan tools


====================================================================================
SECTION 2: ON-CHAIN PROGRAM FEATURES & TESTING
====================================================================================

FILE: programs/dvpn/src/lib.rs
DEPLOY: anchor build && anchor deploy


FEATURE 2.1: PROVIDER REGISTRATION
-----------------------------------
WHAT IT DOES:
- Creates a Provider account (PDA)
- Initializes reputation_score to 1000 (neutral)
- Sets node_count to 0
- Prepares for staking (stake_lamports field)

HOW TO TEST:
```bash
# Method 1: Using test script
anchor run mvp

# Method 2: Manual with Anchor client
ts-node <<EOF
import * as anchor from "@coral-xyz/anchor";
const provider = anchor.AnchorProvider.env();
const program = anchor.workspace.Dvpn;
const authority = provider.wallet.publicKey;

const [providerPDA] = await anchor.web3.PublicKey.findProgramAddress(
  [Buffer.from("provider"), authority.toBuffer()],
  program.programId
);

await program.methods
  .registerProvider()
  .accounts({
    authority: authority,
    provider: providerPDA,
    systemProgram: anchor.web3.SystemProgram.programId,
  })
  .rpc();

console.log("Provider created:", providerPDA.toString());
EOF
```

VERIFICATION:
```bash
# Fetch provider account
node scripts/fetch_provider_and_sessions.js
# Should show: reputation_score: 1000, node_count: 0, stake_lamports: 0
```


FEATURE 2.2: NODE REGISTRATION
-------------------------------
WHAT IT DOES:
- Registers a VPN node under a provider
- Sets endpoint (IP:port), region, pricing
- Stores WireGuard server public key
- Sets capacity limits (max_capacity)
- Tracks active_sessions and total_uptime_seconds

HOW TO TEST:
```bash
# Using MVP script (creates provider + node)
anchor run mvp

# Manual registration
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

const nodeId = 0;
const endpoint = "vpn.example.com:51820";
const region = "US";
const pricePerMinute = 1000000; // 0.001 SOL per minute
const wgPubkey = Buffer.from("YOUR_WG_SERVER_PUBKEY_32_BYTES");
const maxCapacity = 100;

// Derive PDAs
const [providerPDA] = await anchor.web3.PublicKey.findProgramAddress(
  [Buffer.from("provider"), provider.wallet.publicKey.toBuffer()],
  program.programId
);

const [nodePDA] = await anchor.web3.PublicKey.findProgramAddress(
  [Buffer.from("node"), providerPDA.toBuffer(), Buffer.from(new BigUint64Array([BigInt(nodeId)]).buffer)],
  program.programId
);

await program.methods
  .registerNode(new anchor.BN(nodeId), endpoint, region, new anchor.BN(pricePerMinute), wgPubkey, maxCapacity)
  .accounts({
    authority: provider.wallet.publicKey,
    provider: providerPDA,
    node: nodePDA,
    systemProgram: anchor.web3.SystemProgram.programId,
  })
  .rpc();

console.log("Node created:", nodePDA.toString());
EOF
```

VERIFICATION:
```bash
# Fetch node details
node scripts/fetch_node.js
# Should show: endpoint, region, price, capacity, active_sessions: 0
```


FEATURE 2.3: SESSION CREATION (SOL PAYMENT)
--------------------------------------------
WHAT IT DOES:
- User deposits SOL for fixed time (e.g., 60 minutes)
- Creates Session PDA with escrow
- Increments node's active_sessions
- Increments provider's total_sessions
- Sets payment_token to default (SOL)

HOW TO TEST:
```bash
# Method 1: Using daemon server
curl -X POST http://localhost:3000/session \
  -H 'Content-Type: application/json' \
  -d '{
    "keypairPath": "./user-keypair.json",
    "sessionId": 1,
    "minutes": 60
  }'

# Method 2: Manual script
node scripts/create_session_manual.js

# Method 3: Programmatic
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

const sessionId = 1;
const minutes = 60;
const nodePublicKey = new anchor.web3.PublicKey("YOUR_NODE_PUBKEY");

// Fetch node to get provider
const node = await program.account.node.fetch(nodePublicKey);

// Derive session PDA
const [sessionPDA] = await anchor.web3.PublicKey.findProgramAddress(
  [Buffer.from("session"), provider.wallet.publicKey.toBuffer(), nodePublicKey.toBuffer(), Buffer.from(new BigUint64Array([BigInt(sessionId)]).buffer)],
  program.programId
);

await program.methods
  .openSession(new anchor.BN(sessionId), minutes)
  .accounts({
    user: provider.wallet.publicKey,
    provider: node.provider,
    node: nodePublicKey,
    session: sessionPDA,
    systemProgram: anchor.web3.SystemProgram.programId,
  })
  .rpc();

console.log("Session created:", sessionPDA.toString());
EOF
```

VERIFICATION:
```bash
# Scan all sessions
node scripts/scan_sessions.js
# Should show new session with state: "Active", escrow_lamports > 0

# Check session balance
solana balance <SESSION_PDA>
# Should match escrow amount
```


FEATURE 2.4: SESSION CREATION (USDC/SPL PAYMENT)
-------------------------------------------------
WHAT IT DOES:
- Same as 2.3 but accepts SPL tokens (USDC)
- Transfers tokens to session token account
- Sets payment_token to USDC mint address

HOW TO TEST:
```bash
# Requires USDC tokens in user wallet
node <<EOF
const anchor = require("@coral-xyz/anchor");
const { Token, TOKEN_PROGRAM_ID } = require("@solana/spl-token");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

const sessionId = 2;
const minutes = 60;
const usdcMint = new anchor.web3.PublicKey("USDC_MINT_ADDRESS");
const amountTokens = 1000000; // 1 USDC (6 decimals)
const nodePublicKey = new anchor.web3.PublicKey("YOUR_NODE_PUBKEY");

// Get user's USDC token account
const userTokenAccount = await Token.getAssociatedTokenAddress(
  /* ... */
);

// Derive session token account
const sessionTokenAccount = /* derive ATA for session PDA */;

await program.methods
  .openSessionSpl(new anchor.BN(sessionId), minutes, new anchor.BN(amountTokens))
  .accounts({
    user: provider.wallet.publicKey,
    provider: /* provider PDA */,
    node: nodePublicKey,
    session: /* session PDA */,
    mint: usdcMint,
    userTokenAccount: userTokenAccount,
    sessionTokenAccount: sessionTokenAccount,
    tokenProgram: TOKEN_PROGRAM_ID,
    systemProgram: anchor.web3.SystemProgram.programId,
  })
  .rpc();
EOF
```

VERIFICATION:
```bash
# Check session payment_token field
solana account <SESSION_PDA> | grep payment_token
# Should show USDC mint address, not default pubkey
```


FEATURE 2.5: USAGE-BASED BILLING (CLAIM CHUNK)
-----------------------------------------------
WHAT IT DOES:
- Provider submits receipt for partial payment
- Updates session's bytes_used and last_proof_hash
- Transfers chunk amount from session to provider
- Decrements remaining_balance

HOW TO TEST:
```bash
# Requires active session and provider keypair
node <<EOF
const anchor = require("@coral-xyz/anchor");
const fs = require("fs");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

const sessionPDA = new anchor.web3.PublicKey("SESSION_PDA");
const bytesUsed = 1000000; // 1 MB
const proofHash = Buffer.from("some_hash_32_bytes".padEnd(32, '0'));
const claimAmount = 100000; // lamports

await program.methods
  .claimChunk(new anchor.BN(bytesUsed), Array.from(proofHash), new anchor.BN(claimAmount))
  .accounts({
    authority: provider.wallet.publicKey,
    provider: /* provider PDA */,
    session: sessionPDA,
  })
  .rpc();

console.log("Chunk claimed");
EOF

# Or use enhanced daemon (auto-submits every 5 min)
PROVIDER_KEYPAIR=./provider-keypair.json node scripts/node_daemon_enhanced.js
```

VERIFICATION:
```bash
# Fetch session
node scripts/scan_sessions.js
# Check: bytes_used increased, remaining_balance decreased
```


FEATURE 2.6: PARTIAL REFUNDS (CLOSE SESSION)
---------------------------------------------
WHAT IT DOES:
- User closes session before expiry
- Calculates elapsed time vs total duration
- Refunds proportional unused amount
- Sets state to Closed
- Decrements node's active_sessions

HOW TO TEST:
```bash
# Close session early
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

const sessionPDA = new anchor.web3.PublicKey("SESSION_PDA");
const nodePDA = new anchor.web3.PublicKey("NODE_PDA");

// Get user balance before
const balanceBefore = await provider.connection.getBalance(provider.wallet.publicKey);

await program.methods
  .closeSession()
  .accounts({
    user: provider.wallet.publicKey,
    session: sessionPDA,
    node: nodePDA,
  })
  .rpc();

// Get user balance after
const balanceAfter = await provider.connection.getBalance(provider.wallet.publicKey);
const refund = balanceAfter - balanceBefore;

console.log("Refund received:", refund, "lamports");
EOF
```

VERIFICATION:
```bash
# Check user received refund
# User balance should increase
# Session state should be "Closed"
# remaining_balance should be less than escrow_lamports
```


FEATURE 2.7: CLAIM PAYOUT (FINAL PAYMENT)
------------------------------------------
WHAT IT DOES:
- Provider claims remaining balance after session ends/closes
- Transfers all remaining_balance to provider
- Updates uptime stats (total_uptime_seconds)
- Sets state to Claimed
- Decrements active_sessions if not already done

HOW TO TEST:
```bash
# Manual claim
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

const sessionPDA = new anchor.web3.PublicKey("SESSION_PDA");

await program.methods
  .claimPayout()
  .accounts({
    authority: provider.wallet.publicKey,
    provider: /* provider PDA */,
    node: /* node PDA */,
    session: sessionPDA,
  })
  .rpc();

console.log("Payout claimed");
EOF

# Or use enhanced daemon (auto-claims every 10 min)
PROVIDER_KEYPAIR=./provider-keypair.json node scripts/node_daemon_enhanced.js
```

VERIFICATION:
```bash
# Session state = "Claimed"
# Provider balance increased
# Provider total_uptime_seconds increased
# Node total_uptime_seconds increased
```


FEATURE 2.8: DISPUTE MECHANISM
-------------------------------
WHAT IT DOES:
- User or provider raises dispute on session
- Sets state to Disputed
- Dispute can be resolved with refunds and slashing

HOW TO TEST:
```bash
# Raise dispute (as user or provider)
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

const sessionPDA = new anchor.web3.PublicKey("SESSION_PDA");
const reason = "Poor connection quality";

await program.methods
  .raiseDispute(reason)
  .accounts({
    authority: provider.wallet.publicKey,
    provider: /* provider PDA */,
    session: sessionPDA,
  })
  .rpc();

console.log("Dispute raised");
EOF

# Resolve dispute (requires governance/arbitrator)
node <<EOF
await program.methods
  .resolveDispute(new anchor.BN(500000), new anchor.BN(100000)) // refund, slash
  .accounts({
    resolver: provider.wallet.publicKey,
    provider: /* provider PDA */,
    session: sessionPDA,
    user: /* user pubkey */,
  })
  .rpc();

console.log("Dispute resolved");
EOF
```

VERIFICATION:
```bash
# After raise: session state = "Disputed"
# After resolve: state = "Resolved", user refunded, provider slashed
```


FEATURE 2.9: REPUTATION SYSTEM
-------------------------------
WHAT IT DOES:
- Users rate providers after session completion
- Updates provider's reputation_score (moving average)
- Score range: 0-2000 (starts at 1000)
- Used by clients to choose best nodes

HOW TO TEST:
```bash
# Rate provider after session
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

const sessionPDA = new anchor.web3.PublicKey("SESSION_PDA");
const rating = 900; // 0-1000 scale (900 = excellent)

await program.methods
  .updateReputation(rating)
  .accounts({
    user: provider.wallet.publicKey,
    provider: /* provider PDA */,
    session: sessionPDA,
  })
  .rpc();

console.log("Reputation updated");
EOF
```

VERIFICATION:
```bash
# Fetch provider
node scripts/fetch_provider_and_sessions.js
# Check reputation_score changed
# Formula: new_score = (old_score * 9 + rating) / 10
```


FEATURE 2.10: STAKING (RESERVED - NOT DEPLOYED YET)
----------------------------------------------------
WHAT IT DOES:
- Provider locks SOL as stake (anti-Sybil)
- Stake can be slashed during disputes
- Increases provider credibility

HOW TO TEST (when enabled):
```bash
node <<EOF
await program.methods
  .stakeProvider(new anchor.BN(10000000000)) // 10 SOL
  .accounts({
    authority: provider.wallet.publicKey,
    provider: /* provider PDA */,
    systemProgram: anchor.web3.SystemProgram.programId,
  })
  .rpc();
EOF
```

STATUS: Code implemented but not deployed. Needs governance before enabling.


====================================================================================
SECTION 3: OFF-CHAIN INFRASTRUCTURE & TESTING
====================================================================================

FEATURE 3.1: NODE DAEMON SERVER
--------------------------------
FILE: scripts/node_daemon_server.js
PORT: 3000 (default)

WHAT IT DOES:
- HTTP API for session authentication
- Verifies user signatures
- Adds WireGuard peers automatically
- Allocates client IPs (10.10.0.4-254)
- Auto-removes expired peers every 60s
- Idempotent (can retry auth safely)

ENDPOINTS:
- GET /node - Returns node details
- GET /session/:pda - Returns session details
- POST /session - Creates new session on-chain
- POST /session/auth - Authenticates client and adds WG peer

HOW TO TEST:

Step 1: Start daemon
```bash
# Ensure WireGuard interface is up
sudo wireguard-go wg0
sudo wg-quick up wg0  # or use your config

# Start daemon
NODE_PUB=<your_node_pubkey> PROVIDER_PUB=<your_provider_pubkey> node scripts/node_daemon_server.js

# Output: {"ts":"...","level":"info","msg":"node daemon server listening","port":3000}
```

Step 2: Test endpoints
```bash
# Get node info
curl http://localhost:3000/node

# Get session info
curl http://localhost:3000/session/<SESSION_PDA>

# Create session
curl -X POST http://localhost:3000/session \
  -H 'Content-Type: application/json' \
  -d '{
    "keypairPath": "./user-keypair.json",
    "sessionId": 1,
    "minutes": 60
  }'
```

Step 3: Test authentication
```bash
# Generate WireGuard keypair
wg genkey > client_private.key
wg pubkey < client_private.key > client_public.key
CLIENT_WG_PUBKEY=$(cat client_public.key)

# Sign the pubkey with user wallet
# (Use solana-keygen or your signing tool)
USER_SIGNATURE="<base58_signature>"

# Authenticate
curl -X POST http://localhost:3000/session/auth \
  -H 'Content-Type: application/json' \
  -d "{
    \"sessionPda\": \"<SESSION_PDA>\",
    \"clientWgPubkey\": \"$CLIENT_WG_PUBKEY\",
    \"signature\": \"$USER_SIGNATURE\"
  }"

# Should return:
# {"assignedIp":"10.10.0.X","clientConfig":{...}}
```

Step 4: Verify WireGuard peer added
```bash
sudo wg show wg0
# Should see new peer with allowed-ips 10.10.0.X/32
```

Step 5: Test auto cleanup
```bash
# Wait for session to expire (or manually expire time)
# After 60s, daemon should remove peer
# Check logs: {"level":"info","msg":"removed expired peer","sessionPda":"..."}

# Verify peer removed
sudo wg show wg0
# Peer should be gone
```


FEATURE 3.2: ENHANCED NODE DAEMON
----------------------------------
FILE: scripts/node_daemon_enhanced.js

WHAT IT DOES:
- Monitors WireGuard traffic (Linux only)
- Submits usage receipts every 5 minutes (claim_chunk)
- Auto-claims final payouts every 10 minutes (claim_payout)
- Updates provider uptime statistics

HOW TO TEST:

Step 1: Setup
```bash
# Requires provider keypair
export PROVIDER_KEYPAIR=./provider-keypair.json
export NODE_PUB=<your_node_pubkey>
export PROVIDER_PUB=<your_provider_pubkey>
```

Step 2: Start daemon
```bash
node scripts/node_daemon_enhanced.js

# Output:
# Enhanced node daemon started
# Polling sessions every 30 seconds
# Submitting receipts every 5 minutes
# Claiming payouts every 10 minutes
```

Step 3: Create active session (as user)
```bash
# Use create_session_manual.js or HTTP API
node scripts/create_session_manual.js
```

Step 4: Monitor logs
```bash
# Watch for receipt submissions
# {"level":"info","msg":"submitted receipt","session":"...","bytes":12345,"amount":...}

# Watch for payout claims
# {"level":"info","msg":"claimed payout","session":"...","amount":...}
```

Step 5: Verify on-chain
```bash
# Check session bytes_used increasing
node scripts/scan_sessions.js | grep bytes_used

# Check provider balance increasing
solana balance <PROVIDER_AUTHORITY_PUBKEY>
```


FEATURE 3.3: WIREGUARD INTEGRATION
-----------------------------------
WHAT IT DOES:
- Server-side WireGuard configuration
- Dynamic peer management
- IP allocation
- Traffic routing

HOW TO TEST:

Step 1: Setup WireGuard server
```bash
# Generate server keypair
wg genkey | tee wg_server_private | wg pubkey > wg_server_public

# Create config
sudo nano /etc/wireguard/wg0.conf
```

Config:
```
[Interface]
Address = 10.10.0.1/24
ListenPort = 51820
PrivateKey = <wg_server_private>
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
```

Step 2: Start WireGuard
```bash
sudo wg-quick up wg0

# Verify
sudo wg show wg0
```

Step 3: Test with client
```bash
# On client machine, create config with daemon's response
# [Interface]
# PrivateKey = <client_private>
# Address = 10.10.0.X/32
# 
# [Peer]
# PublicKey = <server_public>
# Endpoint = <node_endpoint>:51820
# AllowedIPs = 0.0.0.0/0
# PersistentKeepalive = 25

# Start client
sudo wg-quick up wg0-client

# Test connection
ping 10.10.0.1
curl -I https://ipinfo.io/ip  # Should show node's IP
```


====================================================================================
SECTION 4: INDEXER SERVICE TESTING
====================================================================================

FEATURE 4.1: DATABASE SETUP
----------------------------
FILE: indexer/db.js

WHAT IT DOES:
- PostgreSQL schema for providers, nodes, sessions
- Indexes for fast queries
- Upsert functions for atomic updates

HOW TO TEST:

Step 1: Install PostgreSQL
```bash
# macOS
brew install postgresql@14
brew services start postgresql@14

# Linux
sudo apt install postgresql
sudo systemctl start postgresql
```

Step 2: Create database
```bash
createdb dvpn_indexer

# Verify
psql dvpn_indexer -c "SELECT version();"
```

Step 3: Test schema creation
```bash
cd indexer
npm install

# Start indexer (will auto-create schema)
node indexer.js

# Verify tables created
psql dvpn_indexer -c "\dt"
# Should show: providers, nodes, sessions
```

Step 4: Query data
```bash
# Check providers
psql dvpn_indexer -c "SELECT pubkey, reputation_score FROM providers;"

# Check nodes
psql dvpn_indexer -c "SELECT pubkey, endpoint, region, is_active FROM nodes;"

# Check sessions
psql dvpn_indexer -c "SELECT pubkey, state, start_ts, end_ts FROM sessions;"
```


FEATURE 4.2: BLOCKCHAIN SYNCING
--------------------------------
FILE: indexer/indexer.js

WHAT IT DOES:
- Polls Solana program every 5 seconds
- Decodes all Provider/Node/Session accounts
- Updates PostgreSQL atomically
- Handles state changes (Active ‚Üí Closed ‚Üí Claimed)

HOW TO TEST:

Step 1: Configure RPC
```bash
export RPC_ENDPOINT=http://127.0.0.1:8899  # or testnet URL
export POLL_INTERVAL_MS=5000
```

Step 2: Start indexer
```bash
cd indexer
node indexer.js

# Output:
# üöÄ Starting DVPN Indexer...
# üì° RPC: http://127.0.0.1:8899
# üîÑ Indexing providers...
# ‚úÖ Indexed 1 providers
# üîÑ Indexing nodes...
# ‚úÖ Indexed 2 nodes
# ‚è∞ Polling every 5000ms...
```

Step 3: Make on-chain changes
```bash
# In another terminal, create session
node scripts/create_session_manual.js
```

Step 4: Watch indexer logs
```bash
# Should see within 5 seconds:
# üîÑ Indexing sessions...
# ‚úÖ Indexed 1 sessions
```

Step 5: Verify database updated
```bash
psql dvpn_indexer -c "SELECT COUNT(*) FROM sessions WHERE state = 'Active';"
# Should show 1
```


FEATURE 4.3: REST API
---------------------
FILE: indexer/api.js
PORT: 3001 (default)

WHAT IT DOES:
- Query endpoints for nodes, sessions, providers
- Filters by region, reputation, user, state
- Statistics endpoint

HOW TO TEST:

Step 1: Start API
```bash
cd indexer
node api.js

# Or start both together
npm run dev

# Output:
# üåê API server running on http://localhost:3001
```

Step 2: Test endpoints
```bash
# Health check
curl http://localhost:3001/health

# Get all nodes
curl http://localhost:3001/nodes

# Filter by region
curl http://localhost:3001/nodes?region=US

# Filter by active status
curl http://localhost:3001/nodes?is_active=true

# Filter by reputation
curl http://localhost:3001/nodes?min_reputation=900

# Get specific node
curl http://localhost:3001/nodes/<NODE_PUBKEY>

# Get all sessions
curl http://localhost:3001/sessions

# Get user sessions
curl http://localhost:3001/sessions?user=<USER_PUBKEY>

# Get node sessions
curl http://localhost:3001/sessions?node=<NODE_PUBKEY>

# Get active sessions only
curl http://localhost:3001/sessions?state=Active

# Get provider details with nodes
curl http://localhost:3001/providers/<PROVIDER_PUBKEY>

# Get global statistics
curl http://localhost:3001/stats
```

Step 3: Verify data
```bash
# Get nodes, check fields exist
curl http://localhost:3001/nodes | jq '.'

# Expected structure:
# {
#   "nodes": [
#     {
#       "pubkey": "...",
#       "endpoint": "vpn.example.com:51820",
#       "region": "US",
#       "price_per_minute_lamports": "1000000",
#       "reputation_score": 1000,
#       "is_active": true
#     }
#   ],
#   "count": 1
# }
```


====================================================================================
SECTION 5: FULL END-TO-END TESTING WORKFLOW
====================================================================================

COMPLETE VPN SESSION LIFECYCLE
-------------------------------

Prerequisites:
- Solana validator running (local or testnet)
- Program deployed
- Provider + Node registered
- WireGuard server configured
- Node daemon running
- Indexer running (optional but recommended)

STEP 1: Setup Provider & Node
```bash
# Deploy program
anchor build
anchor deploy

# Update program ID in Anchor.toml and lib.rs
# Rebuild and deploy again

# Create provider and node
anchor run mvp

# Verify
node scripts/fetch_node.js
# Note the node pubkey
```

STEP 2: Start Infrastructure
```bash
# Terminal 1: Node daemon server
NODE_PUB=<your_node_pubkey> PROVIDER_PUB=<your_provider_pubkey> \
  node scripts/node_daemon_server.js

# Terminal 2: Enhanced daemon (optional, for auto-claims)
PROVIDER_KEYPAIR=./provider-keypair.json \
NODE_PUB=<your_node_pubkey> PROVIDER_PUB=<your_provider_pubkey> \
  node scripts/node_daemon_enhanced.js

# Terminal 3: Indexer (optional)
cd indexer && npm run dev

# Terminal 4: WireGuard (if not already running)
sudo wg-quick up wg0
```

STEP 3: Create Session (User)
```bash
# User creates session
curl -X POST http://localhost:3000/session \
  -H 'Content-Type: application/json' \
  -d '{
    "keypairPath": "./user-keypair.json",
    "sessionId": 1,
    "minutes": 60
  }'

# Save the sessionPda from response
SESSION_PDA="<from_response>"
```

STEP 4: Authenticate (User)
```bash
# Generate WireGuard keypair
wg genkey > client_private.key
wg pubkey < client_private.key > client_public.key
CLIENT_WG_PUBKEY=$(cat client_public.key)

# Sign the pubkey with user wallet
# (In production, use solana-keygen or wallet adapter)
# For testing, use your signing method
USER_SIGNATURE="<base58_signature_of_client_wg_pubkey>"

# Authenticate with node
curl -X POST http://localhost:3000/session/auth \
  -H 'Content-Type: application/json' \
  -d "{
    \"sessionPda\": \"$SESSION_PDA\",
    \"clientWgPubkey\": \"$CLIENT_WG_PUBKEY\",
    \"signature\": \"$USER_SIGNATURE\"
  }"

# Save response: assignedIp and clientConfig
```

STEP 5: Configure Client VPN
```bash
# Create WireGuard config
cat > wg-client.conf <<EOF
[Interface]
PrivateKey = $(cat client_private.key)
Address = <assignedIp>/32
DNS = 1.1.1.1

[Peer]
PublicKey = <server_public_key_from_auth_response>
Endpoint = <node_endpoint_from_auth_response>
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25
EOF

# Start VPN
sudo wg-quick up wg-client

# Test connection
ping 10.10.0.1
curl https://ipinfo.io/ip  # Should show node's IP
```

STEP 6: Monitor Usage
```bash
# Watch enhanced daemon logs (Terminal 2)
# Should see periodic receipt submissions:
# {"level":"info","msg":"submitted receipt","session":"...","bytes":...}

# Query session via indexer
curl http://localhost:3001/sessions/$SESSION_PDA | jq '.bytes_used'
# Should increase over time
```

STEP 7: Close Session
```bash
# User closes session early
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

await program.methods
  .closeSession()
  .accounts({
    user: provider.wallet.publicKey,
    session: new anchor.web3.PublicKey("$SESSION_PDA"),
    node: new anchor.web3.PublicKey("<NODE_PUBKEY>"),
  })
  .rpc();

console.log("Session closed");
EOF

# Disconnect VPN
sudo wg-quick down wg-client
```

STEP 8: Verify Cleanup
```bash
# Wait 60 seconds
# Node daemon should auto-remove peer

# Check WireGuard
sudo wg show wg0
# Client peer should be gone

# Check session state
curl http://localhost:3001/sessions/$SESSION_PDA | jq '.state'
# Should be "Closed" or "Claimed"

# Check user received refund
solana balance <USER_PUBKEY>
# Should see refund for unused time
```

STEP 9: Verify Provider Payment
```bash
# Enhanced daemon should auto-claim after 10 minutes
# Or manually claim:
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

await program.methods
  .claimPayout()
  .accounts({
    authority: provider.wallet.publicKey,
    provider: /* provider PDA */,
    node: /* node PDA */,
    session: new anchor.web3.PublicKey("$SESSION_PDA"),
  })
  .rpc();
EOF

# Check provider balance
solana balance <PROVIDER_AUTHORITY_PUBKEY>
# Should increase
```

STEP 10: Rate Provider (Optional)
```bash
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

await program.methods
  .updateReputation(950) // Excellent rating
  .accounts({
    user: provider.wallet.publicKey,
    provider: /* provider PDA */,
    session: new anchor.web3.PublicKey("$SESSION_PDA"),
  })
  .rpc();
EOF

# Check reputation updated
curl http://localhost:3001/providers/<PROVIDER_PUBKEY> | jq '.provider.reputation_score'
```


TESTING DISPUTE FLOW
---------------------

STEP 1: Create session (follow steps 1-5 above)

STEP 2: Raise dispute
```bash
node <<EOF
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.env();
const program = new anchor.Program(require("./target/idl/dvpn.json"), provider);

await program.methods
  .raiseDispute("Connection dropped frequently")
  .accounts({
    authority: provider.wallet.publicKey,
    provider: /* provider PDA */,
    session: new anchor.web3.PublicKey("$SESSION_PDA"),
  })
  .rpc();
EOF
```

STEP 3: Verify state
```bash
curl http://localhost:3001/sessions/$SESSION_PDA | jq '.state'
# Should be "Disputed"
```

STEP 4: Resolve dispute (as arbitrator/governance)
```bash
node <<EOF
await program.methods
  .resolveDispute(
    new anchor.BN(500000), // Refund 500000 lamports to user
    new anchor.BN(100000)  // Slash 100000 lamports from provider stake
  )
  .accounts({
    resolver: /* resolver authority */,
    provider: /* provider PDA */,
    session: new anchor.web3.PublicKey("$SESSION_PDA"),
    user: /* user pubkey */,
  })
  .rpc();
EOF
```

STEP 5: Verify resolution
```bash
# Check session state
curl http://localhost:3001/sessions/$SESSION_PDA | jq '.state'
# Should be "Resolved"

# Check user received refund
solana balance <USER_PUBKEY>

# Check provider stake slashed
curl http://localhost:3001/providers/<PROVIDER_PUBKEY> | jq '.provider.stake_lamports'
```


====================================================================================
SECTION 6: RESERVED FEATURES (Not Deployed Yet)
====================================================================================

FEATURE 6.1: PROVIDER STAKING
------------------------------
STATUS: Code implemented, deployment reserved for later

WHY RESERVED:
- Needs governance mechanism for dispute resolution
- Requires setting minimum stake requirements
- Should validate core VPN functionality first

WHAT IT DOES:
- Providers lock SOL as stake (anti-Sybil)
- Stake can be slashed on disputes
- Higher stake = higher trust

INSTRUCTIONS (when enabled):
```rust
// In lib.rs, instructions already exist:
pub fn stake_provider(ctx: Context<StakeProvider>, amount_lamports: u64) -> Result<()>
pub fn unstake_provider(ctx: Context<UnstakeProvider>, amount_lamports: u64) -> Result<()>
```

HOW TO TEST (when enabled):
```bash
# Stake 10 SOL
node <<EOF
await program.methods
  .stakeProvider(new anchor.BN(10_000_000_000))
  .accounts({
    authority: provider.wallet.publicKey,
    provider: /* provider PDA */,
    systemProgram: anchor.web3.SystemProgram.programId,
  })
  .rpc();
EOF

# Verify
curl http://localhost:3001/providers/<PROVIDER_PUBKEY> | jq '.provider.stake_lamports'
# Should show 10000000000
```

NEXT STEPS TO ENABLE:
1. ‚úÖ Test core VPN functionality thoroughly
2. Deploy governance/multi-sig for dispute resolution
3. Set minimum stake policy (e.g., 5 SOL minimum)
4. Update client UI to show provider stakes
5. Redeploy program with staking enabled


FEATURE 6.2: ELECTRON CLIENT
-----------------------------
STATUS: Scaffolded, not completed

WHY RESERVED:
- Indexer API needs production testing
- Node daemon behavior needs validation
- UX flow needs design

WHAT IT WOULD DO:
- Wallet connection (Phantom, Solflare)
- Browse nodes from indexer API
- Create sessions with one click
- Auto-generate WireGuard config
- Apply config to local WireGuard
- Monitor connection status
- Disconnect and close sessions

FILES PREPARED:
- app/package.json - Dependencies defined
- app/main.js - IPC handlers for session creation, auth, WG config
- app/index.html - UI mockup

HOW TO TEST (when completed):
```bash
cd app
npm install
npm start
```

NEXT STEPS TO ENABLE:
1. ‚úÖ Stabilize indexer API
2. ‚úÖ Validate node daemon on multiple platforms
3. Design UX mockups
4. Implement wallet adapter
5. Build main process logic
6. Create renderer process
7. Test on macOS, Linux, Windows
8. Package with electron-builder


====================================================================================
SUMMARY: WHAT'S WORKING NOW
====================================================================================

‚úÖ FULLY FUNCTIONAL:
1. Provider/Node registration with reputation tracking
2. Session creation (SOL and USDC payments)
3. WireGuard peer authentication and management
4. Usage-based billing with automatic receipts
5. Partial refunds for early closure
6. Dispute mechanism with slashing
7. Reputation system with user ratings
8. Auto peer cleanup at session expiry
9. PostgreSQL indexer with REST API
10. Traffic monitoring and auto-claims

‚è≥ INFRASTRUCTURE READY, DEPLOYMENT RESERVED:
1. Staking/slashing (needs governance)
2. Electron client (needs UX design)

üìù TESTING STATUS:
- All on-chain instructions: ‚úÖ Testable now
- Node daemon: ‚úÖ Working and tested
- Indexer: ‚úÖ Working and tested
- End-to-end flow: ‚úÖ Fully testable
- Staking: ‚è≥ Code ready, governance needed
- Electron client: ‚è≥ Scaffolded, implementation pending


====================================================================================
QUICK START TESTING CHECKLIST
====================================================================================

‚ñ° 1. Deploy program: anchor build && anchor deploy
‚ñ° 2. Create provider + node: anchor run mvp
‚ñ° 3. Start WireGuard: sudo wg-quick up wg0
‚ñ° 4. Start node daemon: node scripts/node_daemon_server.js
‚ñ° 5. Start indexer: cd indexer && npm run dev
‚ñ° 6. Create session: curl -X POST http://localhost:3000/session ...
‚ñ° 7. Authenticate client: curl -X POST http://localhost:3000/session/auth ...
‚ñ° 8. Configure VPN: sudo wg-quick up wg-client
‚ñ° 9. Test connection: ping 10.10.0.1 && curl ipinfo.io/ip
‚ñ° 10. Close session: node close_session.js
‚ñ° 11. Verify cleanup: sudo wg show wg0 (peer removed)
‚ñ° 12. Check indexer: curl http://localhost:3001/stats

All features working = ‚úÖ DVPN ready for production!


====================================================================================
END OF TEST GUIDE
====================================================================================
